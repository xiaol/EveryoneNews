// AlamofireImplementations.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Alamofire

class AlamofireRequestBuilderFactory: RequestBuilderFactory {
    func getBuilder<T>() -> RequestBuilder<T>.Type {
        return AlamofireRequestBuilder<T>.self
    }
}

// Store manager to retain its reference
private var managerStore: [String: SessionManager] = [:]

class AlamofireRequestBuilder<T>: RequestBuilder<T> {
    required init(method: String, URLString: String, parameters: [String : AnyObject]?, isBody: Bool) {
        super.init(method: method, URLString: URLString, parameters: parameters, isBody: isBody)
    }
    
    
    
    // Create a new manager for each request to customize its request header
override func execute(_ completion:  @escaping (Response<T>?, Error?) -> Void) {
        let managerId = NSUUID().uuidString
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = buildHeaders()
        let manager = Alamofire.SessionManager(configuration: configuration)
        managerStore[managerId] = manager
        
        let encoding:ParameterEncoding = isBody ? JSONEncoding.default : URLEncoding.default
        let xMethod = HTTPMethod(rawValue: method)
        let fileKeys = parameters == nil ? [] : parameters!.filter { $1 is URL } .map { $0.0 }
        
        if fileKeys.count > 0 {
            
            
                print("没有做文件上传")
            
//            manager.upload(
//                multipartFormData: { mpForm in
//                    for (k, v) in self.parameters! {
//                        switch v {
//                        case let fileURL as NSURL:
//                            mpForm.appendBodyPart(fileURL: fileURL, name: k)
//                            break
//                        case let string as NSString:
//                            mpForm.appendBodyPart(data: string.dataUsingEncoding(NSUTF8StringEncoding)!, name: k)
//                            break
//                        case let number as NSNumber:
//                            mpForm.appendBodyPart(data: number.stringValue.dataUsingEncoding(NSUTF8StringEncoding)!, name: k)
//                            break
//                        default:
//                            fatalError("Unprocessable value \(v) with key \(k)")
//                            break
//                        }
//                    }
//                }, usingThreshold: xMethod!, to: URLString,
//                   method: SessionManager.MultipartFormDataEncodingMemoryThreshold,
//                   headers: nil,
//                encodingCompletion: { encodingResult in
//                    switch encodingResult {
//                    case .Success(let uploadRequest, _, _):
//                        self.processRequest(uploadRequest, managerId, completion)
//                    case .Failure(let encodingError):
//                        completion(response: nil, error: encodingError)
//                    }
//                }
//            )
        } else {
            let request = manager.request(URLString, method: xMethod!, parameters: parameters, encoding: encoding)
            
            processRequest(request: request, managerId, completion)
            
        }
        
    }
    
    private func processRequest(request: DataRequest, _ managerId: String, _ completion: @escaping (Response<T>?, Error?) -> Void) {
        if let credential = self.credential {
            request.authenticate(usingCredential: credential)
        }
        
        let cleanupRequest = {
            managerStore.removeValue(forKey: managerId)
        }
        
        let validatedRequest = request.validate()
        switch T.self {
        case is NSData.Type:
            
            validatedRequest.responseData(completionHandler: { (dataResponse) in
                cleanupRequest()
                
                if (dataResponse.result.isFailure) {
                    completion(
                        nil,
                        dataResponse.result.error
                    )
                    return
                }
                
                completion(
                    Response(
                        response: dataResponse.response!,
                        body: dataResponse.data as! T
                    ),
                    nil
                )
            })
        default:
            validatedRequest.responseJSON(options: .allowFragments) { response in
                cleanupRequest()
                
                if response.result.isFailure {
                    completion(nil, response.result.error)
                    return
                }
                
//                if () is T {
//                    completion(Response(response: response.response!, body: () as! T), nil)
//                    return
//                }
                if let json: AnyObject = response.result.value as AnyObject? {
                    let body = Decoders.decode(clazz: T.self, source: json)
                    completion(Response(response: response.response!, body: body), nil)
                    return
                } else if "" is T {
                    // swagger-parser currently doesn't support void, which will be fixed in future swagger-parser release
                    // https://github.com/swagger-api/swagger-parser/pull/34
                    completion(Response(response: response.response!, body: "" as! T), nil)
                    return
                }
                
                completion(nil, NSError(domain: "localhost", code: 500, userInfo: ["reason": "unreacheable code"]))
            }
        }
    }
    
    private func buildHeaders() -> [String: AnyObject] {
        var httpHeaders = SessionManager.defaultHTTPHeaders
        for (key, value) in self.headers {
            httpHeaders[key] = value
        }
        return httpHeaders as [String : AnyObject]
    }
}
